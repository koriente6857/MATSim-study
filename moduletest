package org.example;

import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.TransportMode;
import org.matsim.api.core.v01.network.Link;
import org.matsim.api.core.v01.network.Network;
import org.matsim.api.core.v01.population.*;
import org.matsim.contrib.common.util.StraightLineKnnFinder;
import org.matsim.contrib.ev.EvConfigGroup;
import org.matsim.contrib.ev.charging.VehicleChargingHandler;
import org.matsim.contrib.ev.discharging.AuxEnergyConsumption;
import org.matsim.contrib.ev.discharging.DriveEnergyConsumption;
import org.matsim.contrib.ev.fleet.ElectricFleetSpecification;
import org.matsim.contrib.ev.fleet.ElectricFleetUtils;
import org.matsim.contrib.ev.fleet.ElectricVehicle;
import org.matsim.contrib.ev.fleet.ElectricVehicleSpecification;
import org.matsim.contrib.ev.infrastructure.ChargerSpecification;
import org.matsim.contrib.ev.infrastructure.ChargingInfrastructureSpecification;
import org.matsim.core.gbl.Gbl;
import org.matsim.core.gbl.MatsimRandom;
import org.matsim.core.network.NetworkUtils;
import org.matsim.core.population.PopulationUtils;
import org.matsim.core.population.routes.NetworkRoute;
import org.matsim.core.router.DefaultRoutingRequest;
import org.matsim.core.router.LinkWrapperFacility;
import org.matsim.core.router.RoutingModule;
import org.matsim.core.router.RoutingRequest;
import org.matsim.core.router.util.TravelTime;
import org.matsim.facilities.Facility;
import org.matsim.vehicles.Vehicle;
import org.matsim.vehicles.Vehicles;

import java.util.*;

final class MyEvNetworkRoutingModule implements RoutingModule {

    private final String mode;
    private final Network network;
    private final RoutingModule delegate;
    private final ElectricFleetSpecification electricFleet;
    private final ChargingInfrastructureSpecification chargingInfrastructureSpecification;
    private final Random random = MatsimRandom.getLocalInstance();
    private final TravelTime travelTime;
    private final DriveEnergyConsumption.Factory driveConsumptionFactory;
    private final AuxEnergyConsumption.Factory auxConsumptionFactory;
    private final String stageActivityModePrefix; // = mode + CHARGING_IDENTIFIER
    private final String vehicleSuffix;
    private final EvConfigGroup evConfigGroup;
    private final Vehicles vehicles;

    // (디버그/테스트용) 충전 시간을 길면 rest_long, 짧으면 rest_short로 “표기”할 때 쓰던 기준(이제는 라벨 용도 정도)
    private static final double LONG_REST_THRESHOLD = 4 * 3600.0; // 4h

    MyEvNetworkRoutingModule(final String mode,
                             final Network network,
                             final RoutingModule delegate,
                             final ElectricFleetSpecification electricFleet,
                             final ChargingInfrastructureSpecification chargingInfrastructureSpecification,
                             final TravelTime travelTime,
                             final DriveEnergyConsumption.Factory driveConsumptionFactory,
                             final AuxEnergyConsumption.Factory auxConsumptionFactory,
                             final EvConfigGroup evConfigGroup,
                             final Vehicles vehicles) {
        this.travelTime = travelTime;
        Gbl.assertNotNull(network);
        this.delegate = delegate;
        this.network = network;
        this.mode = mode;
        this.electricFleet = electricFleet;
        this.chargingInfrastructureSpecification = chargingInfrastructureSpecification;
        this.driveConsumptionFactory = driveConsumptionFactory;
        this.auxConsumptionFactory = auxConsumptionFactory;
        this.stageActivityModePrefix = mode + VehicleChargingHandler.CHARGING_IDENTIFIER; // ★ 이 타입이 “충전 상호작용”
        this.evConfigGroup = evConfigGroup;
        this.vehicleSuffix = mode.equals(TransportMode.car) ? "" : "_" + mode;
        this.vehicles = vehicles;

        // ⚠️ 이 버전에선 charge-during-activity 타입 등록 API가 없음.
        // 충전은 ‘stage activity’(= stageActivityModePrefix 타입)로 넣어야 동작.
        // 추가로, config 쪽에서 다음을 권장:
        // evConfigGroup.setEnforceChargingInteractionDuration(true);  // 상호작용 duration 강제
        // evConfigGroup.setMinimumChargeTime( ... );                  // 초 단위 최소 충전시간
    }

    @Override
    public List<? extends PlanElement> calcRoute(RoutingRequest request) {
        final Facility fromFacility = request.getFromFacility();
        final Person person = request.getPerson();

        List<? extends PlanElement> basicRoute = delegate.calcRoute(request);
        Id<Vehicle> evId = Id.createVehicleId(person.getId());
        if (!electricFleet.getVehicleSpecifications().containsKey(evId)) {
            return basicRoute;
        }

        ElectricVehicleSpecification evSpec = electricFleet.getVehicleSpecifications().get(evId);
        Plan entirePlan = person.getSelectedPlan();
        Leg currentLeg = findCurrentLeg(entirePlan, fromFacility);
        if (currentLeg == null) {
            return basicRoute;
        }

        double energyAtTripStart = calculateEnergyAtTripStart(entirePlan, currentLeg, evSpec);
        double energyNeededForRestOfDay = calculateEnergyForRestOfDay(entirePlan, currentLeg, evSpec);

        if (energyNeededForRestOfDay > energyAtTripStart) {
            System.out.println("DEBUG: Agent " + person.getId() + " needs to charge! Forecast deficit. Required="
                    + String.format("%.2f", energyNeededForRestOfDay) + ", Available=" + String.format("%.2f", energyAtTripStart));
            return createRouteWithChargingStop(request, basicRoute, evSpec);
        } else {
            // 안전 차원으로 vehicleId 주입
            if (!basicRoute.isEmpty() && basicRoute.get(0) instanceof Leg leg && leg.getRoute() instanceof NetworkRoute nr) {
                nr.setVehicleId(Id.createVehicleId(request.getPerson().getId()));
            }
            return basicRoute;
        }
    }

    private Leg findCurrentLeg(Plan plan, Facility fromFacility) {
        Id<Link> fromLinkId = fromFacility.getLinkId();
        for (int i = 0; i < plan.getPlanElements().size(); i++) {
            PlanElement pe = plan.getPlanElements().get(i);
            if (pe instanceof Leg) {
                if (i > 0 && plan.getPlanElements().get(i - 1) instanceof Activity) {
                    Activity prev = (Activity) plan.getPlanElements().get(i - 1);
                    if (prev.getLinkId().equals(fromLinkId)) {
                        return (Leg) pe;
                    }
                }
            }
        }
        return null;
    }

    private double calculateEnergyAtTripStart(Plan plan, Leg currentLeg, ElectricVehicleSpecification evSpec) {
        double initialEnergy = evSpec.getBatteryCapacity() * getInitialSoc(plan.getPerson());
        double currentEnergy = initialEnergy;

        for (PlanElement pe : plan.getPlanElements()) {
            if (pe == currentLeg) break;

            if (pe instanceof Leg) {
                currentEnergy -= estimateConsumptionForLeg(evSpec, (Leg) pe);
            } else if (pe instanceof Activity) {
                Activity act = (Activity) pe;
                // 만약 이전에 우리 모듈이 rest_*를 넣어 완전충전으로 ‘가정’했다면 여기서 반영(선택)
                if (act.getType().equals("rest_long") || act.getType().equals("rest_short")) {
                    currentEnergy = evSpec.getBatteryCapacity();
                }
            }
        }
        return Math.max(0, currentEnergy);
    }

    private double calculateEnergyForRestOfDay(Plan plan, Leg currentLeg, ElectricVehicleSpecification evSpec) {
        double total = 0;
        boolean after = false;
        for (PlanElement pe : plan.getPlanElements()) {
            if (pe == currentLeg) after = true;
            if (after && pe instanceof Leg) {
                total += estimateConsumptionForLeg(evSpec, (Leg) pe);
            }
        }
        return total;
    }

    private double estimateConsumptionForLeg(ElectricVehicleSpecification ev, Leg leg) {
        if (leg.getRoute() == null || !(leg.getRoute() instanceof NetworkRoute)) return 0;
        return estimateConsumption(ev, leg).values().stream().mapToDouble(Double::doubleValue).sum();
    }

    private Map<Link, Double> estimateConsumption(ElectricVehicleSpecification ev, Leg basicLeg) {
        Map<Link, Double> consumptions = new LinkedHashMap<>();
        NetworkRoute route = (NetworkRoute) basicLeg.getRoute();
        List<Link> links = NetworkUtils.getLinks(network, route.getLinkIds());

        ElectricVehicle pseudoVehicle = ElectricFleetUtils.create(
                ev, driveConsumptionFactory, auxConsumptionFactory,
                v -> charger -> { throw new UnsupportedOperationException(); }
        );
        DriveEnergyConsumption drive = pseudoVehicle.getDriveEnergyConsumption();
        AuxEnergyConsumption aux = pseudoVehicle.getAuxEnergyConsumption();

        double linkEnterTime = basicLeg.getDepartureTime().seconds();
        for (Link l : links) {
            double tt = travelTime.getLinkTravelTime(l, basicLeg.getDepartureTime().seconds(), null, null);
            double e = drive.calcEnergyConsumption(l, tt, linkEnterTime)
                    + aux.calcEnergyConsumption(basicLeg.getDepartureTime().seconds(), tt, l.getId());
            consumptions.put(l, e);
            linkEnterTime += tt;
        }
        return consumptions;
    }

    // ---- charger 후보 필터 & 단위 보정 ----

    private boolean isChargerUsableByVehicle(ElectricVehicleSpecification ev, ChargerSpecification ch) {
        // 이번 데이터는 모두 default 타입이므로 그냥 허용 (필터링 안 함)
        return true;
        // 혹은 더 엄격하게:
        // return "default".equals(ch.getChargerType());
    }

    // plug_power 단위 보정: 1만 미만이면 kW로 보고 W로 변환
    private double toWatts(double plugPowerFromXml) {
        return plugPowerFromXml < 10_000 ? plugPowerFromXml * 1000.0 : plugPowerFromXml;
    }

    // ---- 충전 경유 경로 생성(핵심: stageActivityModePrefix로 stage 액티비티 삽입) ----

    private List<PlanElement> createRouteWithChargingStop(RoutingRequest request,
                                                          List<? extends PlanElement> basicRoute,
                                                          ElectricVehicleSpecification ev) {
        Leg firstLeg = (Leg) basicRoute.get(0);
        List<PlanElement> staged = new ArrayList<>();

        Facility from = request.getFromFacility();
        double t0 = request.getDepartureTime();

        Link startLink = network.getLinks().get(firstLeg.getRoute().getStartLinkId());
        StraightLineKnnFinder<Link, ChargerSpecification> knn = new StraightLineKnnFinder<>(
                4, Link::getCoord, c -> network.getLinks().get(c.getLinkId()).getCoord());

        List<ChargerSpecification> candidates = chargingInfrastructureSpecification.getChargerSpecifications()
                .values()
                .stream()
                .filter(ch -> isChargerUsableByVehicle(ev, ch) || "default".equals(ch.getChargerType()))
                .toList();

        if (candidates.isEmpty()) {
            // vehicleId만 보강해서 반환
            if (!basicRoute.isEmpty() && basicRoute.get(0) instanceof Leg leg && leg.getRoute() instanceof NetworkRoute nr) {
                nr.setVehicleId(Id.createVehicleId(request.getPerson().getId()));
            }
            return new ArrayList<>(basicRoute);
        }

        List<ChargerSpecification> nearest = knn.findNearest(startLink, candidates.stream());
        ChargerSpecification charger = nearest.get(random.nextInt(nearest.size()));
        Link chargerLink = network.getLinks().get(charger.getLinkId());
        Facility chargerFac = new LinkWrapperFacility(chargerLink);

        // 1) from -> charger
        List<? extends PlanElement> toCharger = delegate.calcRoute(DefaultRoutingRequest.of(
                from, chargerFac, t0, request.getPerson(), request.getAttributes()));
        staged.addAll(toCharger);
        if (!toCharger.isEmpty() && toCharger.get(0) instanceof Leg l && l.getRoute() instanceof NetworkRoute nr) {
            nr.setVehicleId(Id.createVehicleId(request.getPerson().getId()));
        }
        Leg l1 = (Leg) toCharger.get(0);
        double tArrive = l1.getDepartureTime().seconds() + l1.getTravelTime().seconds();

        // 2) ★충전 상호작용(stage) 액티비티 (이 타입이어야 실제 플러그인 동작)
        double plugPowerW = toWatts(charger.getPlugPower());
        double capJ = ev.getBatteryCapacity();
        double estimateSec = capJ / plugPowerW; // 0→100% 단순 가정
        double duration = Math.max(evConfigGroup.getMinimumChargeTime(), estimateSec);

        // 라벨용(디버그): 길면 rest_long, 짧으면 rest_short로 텍스트만 붙이고,
        // 실제 타입은 반드시 stageActivityModePrefix 여야 함
        String label = (duration >= LONG_REST_THRESHOLD) ? "rest_long" : "rest_short";
        Activity chargingInteraction = PopulationUtils.createActivityFromLinkId(
                stageActivityModePrefix, chargerLink.getId()); // ★ 핵심
        chargingInteraction.setMaximumDuration(duration);
        // 필요 시: chargingInteraction.getAttributes().putAttribute("rest_label", label);
        staged.add(chargingInteraction);

        double tDepart = tArrive + duration;

        // 3) charger -> to
        List<? extends PlanElement> toDest = delegate.calcRoute(DefaultRoutingRequest.of(
                chargerFac, request.getToFacility(), tDepart, request.getPerson(), request.getAttributes()));
        staged.addAll(toDest);
        if (!toDest.isEmpty() && toDest.get(0) instanceof Leg l2 && l2.getRoute() instanceof NetworkRoute nr2) {
            nr2.setVehicleId(Id.createVehicleId(request.getPerson().getId()));
        }

        return staged;
    }

    private double getInitialSoc(Person person) {
        Id<Vehicle> vehicleId = Id.createVehicleId(person.getId());
        Vehicle vehicle = this.vehicles.getVehicles().get(vehicleId);
        if (vehicle != null) {
            Object socAttribute = vehicle.getAttributes().getAttribute("initialSoc");
            if (socAttribute instanceof Double) return (Double) socAttribute;
        }
        return 1.0;
    }

    @Override
    public String toString() {
        return "[NetworkRoutingModule: mode=" + this.mode + "]";
    }
}
